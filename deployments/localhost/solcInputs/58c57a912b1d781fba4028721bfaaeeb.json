{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "contracts/Crowdfund.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nerror Cowdfund__GoalNotMet();\nerror Crowdfund__NothingToWithdraw();\nerror Crowdfund__TransferFailed();\nerror Crowdfund__NotOwner();\n\ncontract Crowdfund {\n  uint256 private immutable i_goal;\n  bool private s_goalReached;\n  uint256 private s_raised;\n  address private s_crowdfundOwner;\n\n  mapping(address => uint256) private s_addressToContribution;\n\n  modifier onlyOwner() {\n    if (msg.sender != s_crowdfundOwner) {\n      revert Crowdfund__NotOwner();\n    }\n    _;\n  }\n\n  constructor(uint256 _goal, address _creator) {\n    i_goal = _goal;\n    s_goalReached = false;\n    s_raised = 0;\n    s_crowdfundOwner = _creator;\n  }\n\n  receive() external payable {\n    donate();\n  }\n\n  fallback() external payable {\n    donate();\n  }\n\n  function donate() public payable {\n    s_addressToContribution[msg.sender] += msg.value;\n    s_raised += msg.value;\n    updateGoalStatus();\n  }\n\n  function withdraw() public onlyOwner {\n    if (address(this).balance == 0) {\n      revert Crowdfund__NothingToWithdraw();\n    }\n    (bool success, ) = payable(s_crowdfundOwner).call{value: address(this).balance}(\"\");\n    if (!success) {\n      revert Crowdfund__TransferFailed();\n    }\n  }\n\n  function updateGoalStatus() internal {\n    if (address(this).balance < i_goal) {\n      revert Cowdfund__GoalNotMet();\n    }\n    if (address(this).balance >= i_goal) {\n      s_goalReached = true;\n    }\n  }\n\n  function checkIfContributor(address _checkAddress) public view returns (bool) {\n    if (s_addressToContribution[_checkAddress] > 0) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /* GETTER FUNCTIONS */\n  function getOwner() public view returns (address) {\n    return s_crowdfundOwner;\n  }\n\n  function getBalance() public view returns (uint256) {\n    return address(this).balance;\n  }\n\n  function getRaised() public view returns (uint256) {\n    return s_raised;\n  }\n\n  function getGoalReached() public view returns (bool) {\n    return s_goalReached;\n  }\n\n  function getContribution(address _contibutor) public view returns (uint256) {\n    return s_addressToContribution[_contibutor];\n  }\n}\n"
    },
    "contracts/CrowdfundMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.18;\r\n\r\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\r\nimport \"./Crowdfund.sol\";\r\n\r\ncontract CrowdfundMarket {\r\n  using Counters for Counters.Counter;\r\n  Counters.Counter private _funraiserIds;\r\n\r\n  struct CrowdfundObj {\r\n    uint256 fundId;\r\n    string metaUrl;\r\n    address crowdfundContract;\r\n    address owner;\r\n    uint256 goal;\r\n  }\r\n  mapping(uint256 => CrowdfundObj) private s_idToCrowdfund;\r\n  mapping(address => uint256) private s_addressToId;\r\n\r\n  event CrowdfundCreated(\r\n    uint indexed fundId,\r\n    string indexed metaUrl,\r\n    address indexed crowdfundContractAddress,\r\n    address owner,\r\n    uint256 goal\r\n  );\r\n\r\n  function createCrowdfund(uint _goal, string memory _metaUrl) public {\r\n    _funraiserIds.increment();\r\n    uint256 fundId = _funraiserIds.current();\r\n\r\n    Crowdfund crowdfundContract = new Crowdfund(_goal, msg.sender);\r\n    address crowdfundContractAddress = address(crowdfundContract);\r\n    s_addressToId[crowdfundContractAddress] = fundId;\r\n\r\n    s_idToCrowdfund[fundId] = CrowdfundObj(\r\n      fundId,\r\n      _metaUrl,\r\n      crowdfundContractAddress,\r\n      payable(msg.sender),\r\n      _goal\r\n    );\r\n\r\n    emit CrowdfundCreated(fundId, _metaUrl, crowdfundContractAddress, msg.sender, _goal);\r\n  }\r\n\r\n  function getCrowdfund(uint256 _id) public view returns (CrowdfundObj memory) {\r\n    return s_idToCrowdfund[_id];\r\n  }\r\n\r\n  function getActiveFundraisers() public view returns (CrowdfundObj[] memory) {\r\n    uint256 fundraisersCount = _funraiserIds.current();\r\n    uint256 fundraiserGoalsMet = 0;\r\n    bool goalReached;\r\n    for (uint256 i = 0; i < fundraisersCount; i++) {\r\n      Crowdfund contractInstance = Crowdfund(payable(s_idToCrowdfund[i + 1].crowdfundContract));\r\n      goalReached = contractInstance.getGoalReached();\r\n      if (goalReached) fundraiserGoalsMet++;\r\n    }\r\n\r\n    uint256 goalNotReachedCount = _funraiserIds.current() - fundraiserGoalsMet;\r\n    uint256 index = 0;\r\n\r\n    CrowdfundObj[] memory fundraisers = new CrowdfundObj[](goalNotReachedCount);\r\n    for (uint256 i = 0; i < fundraisersCount; i++) {\r\n      Crowdfund contractInstance = Crowdfund(payable(s_idToCrowdfund[i + 1].crowdfundContract));\r\n      goalReached = contractInstance.getGoalReached();\r\n      if (!goalReached) {\r\n        uint256 currentFundId = s_idToCrowdfund[i + 1].fundId;\r\n        CrowdfundObj storage currentCrowdfund = s_idToCrowdfund[currentFundId];\r\n        fundraisers[index] = currentCrowdfund;\r\n        index++;\r\n      }\r\n    }\r\n    return fundraisers;\r\n  }\r\n\r\n  function getMyFundraisers() public view returns (CrowdfundObj[] memory) {\r\n    uint256 fundraisersCount = _funraiserIds.current();\r\n    uint256 myFundraisersCount = 0;\r\n    uint256 index = 0;\r\n\r\n    for (uint256 i = 0; i < fundraisersCount; i++) {\r\n      if (s_idToCrowdfund[i + 1].owner == msg.sender) {\r\n        myFundraisersCount++;\r\n      }\r\n    }\r\n    CrowdfundObj[] memory fundraisers = new CrowdfundObj[](myFundraisersCount);\r\n\r\n    for (uint256 i = 0; i < fundraisersCount; i++) {\r\n      if (s_idToCrowdfund[i + 1].owner == msg.sender) {\r\n        uint256 currentFundId = s_idToCrowdfund[i + 1].fundId;\r\n        CrowdfundObj storage currentCrowdfund = s_idToCrowdfund[currentFundId];\r\n        fundraisers[index] = currentCrowdfund;\r\n        index++;\r\n      }\r\n    }\r\n    return fundraisers;\r\n  }\r\n\r\n  function getMyActiveFundraisers() public view returns (CrowdfundObj[] memory) {\r\n    uint256 fundraisersCount = _funraiserIds.current();\r\n    uint256 myActiveFundraisersCount = 0;\r\n    bool goalReached;\r\n    uint256 index = 0;\r\n\r\n    for (uint256 i = 0; i < fundraisersCount; i++) {\r\n      Crowdfund contractInstance = Crowdfund(payable(s_idToCrowdfund[i + 1].crowdfundContract));\r\n      goalReached = contractInstance.getGoalReached();\r\n      if (s_idToCrowdfund[i + 1].owner == msg.sender && !goalReached) {\r\n        myActiveFundraisersCount++;\r\n      }\r\n    }\r\n    CrowdfundObj[] memory fundraisers = new CrowdfundObj[](myActiveFundraisersCount);\r\n\r\n    for (uint256 i = 0; i < fundraisersCount; i++) {\r\n      Crowdfund contractInstance = Crowdfund(payable(s_idToCrowdfund[i + 1].crowdfundContract));\r\n      goalReached = contractInstance.getGoalReached();\r\n      if (s_idToCrowdfund[i + 1].owner == msg.sender && !goalReached) {\r\n        uint256 currentFundId = s_idToCrowdfund[i + 1].fundId;\r\n        CrowdfundObj storage currentCrowdfund = s_idToCrowdfund[currentFundId];\r\n        fundraisers[index] = currentCrowdfund;\r\n        index++;\r\n      }\r\n    }\r\n    return fundraisers;\r\n  }\r\n\r\n  function getMyCompletedFundraisers() public view returns (CrowdfundObj[] memory) {\r\n    uint256 fundraisersCount = _funraiserIds.current();\r\n    uint256 myCompletedFundraisersCount = 0;\r\n    bool goalReached;\r\n    uint256 index = 0;\r\n\r\n    for (uint256 i = 0; i < fundraisersCount; i++) {\r\n      Crowdfund contractInstance = Crowdfund(payable(s_idToCrowdfund[i + 1].crowdfundContract));\r\n      goalReached = contractInstance.getGoalReached();\r\n      if (s_idToCrowdfund[i + 1].owner == msg.sender && goalReached) {\r\n        myCompletedFundraisersCount++;\r\n      }\r\n    }\r\n    CrowdfundObj[] memory fundraisers = new CrowdfundObj[](myCompletedFundraisersCount);\r\n\r\n    for (uint256 i = 0; i < fundraisersCount; i++) {\r\n      Crowdfund contractInstance = Crowdfund(payable(s_idToCrowdfund[i + 1].crowdfundContract));\r\n      goalReached = contractInstance.getGoalReached();\r\n      if (s_idToCrowdfund[i + 1].owner == msg.sender && goalReached) {\r\n        uint256 currentFundId = s_idToCrowdfund[i + 1].fundId;\r\n        CrowdfundObj storage currentCrowdfund = s_idToCrowdfund[currentFundId];\r\n        fundraisers[index] = currentCrowdfund;\r\n        index++;\r\n      }\r\n    }\r\n    return fundraisers;\r\n  }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}